// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nmonlistenerapi.proto

// to generate protoc --go_out=plugins=grpc:. *.proto

package nmonlistenerapi

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Status int32

const (
	Status_UP   Status = 0
	Status_WARN Status = 1
	Status_DOWN Status = 2
)

var Status_name = map[int32]string{
	0: "UP",
	1: "WARN",
	2: "DOWN",
}

var Status_value = map[string]int32{
	"UP":   0,
	"WARN": 1,
	"DOWN": 2,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{0}
}

type TopoType int32

const (
	TopoType_COUNTRY TopoType = 0
	TopoType_CITY    TopoType = 1
	TopoType_POP     TopoType = 2
)

var TopoType_name = map[int32]string{
	0: "COUNTRY",
	1: "CITY",
	2: "POP",
}

var TopoType_value = map[string]int32{
	"COUNTRY": 0,
	"CITY":    1,
	"POP":     2,
}

func (x TopoType) String() string {
	return proto.EnumName(TopoType_name, int32(x))
}

func (TopoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{1}
}

type DatabaseUpdateRequestMessageType int32

const (
	DatabaseUpdateRequestMessageType_UPDATESTATUS      DatabaseUpdateRequestMessageType = 0
	DatabaseUpdateRequestMessageType_UPDATECOORDINATES DatabaseUpdateRequestMessageType = 1
)

var DatabaseUpdateRequestMessageType_name = map[int32]string{
	0: "UPDATESTATUS",
	1: "UPDATECOORDINATES",
}

var DatabaseUpdateRequestMessageType_value = map[string]int32{
	"UPDATESTATUS":      0,
	"UPDATECOORDINATES": 1,
}

func (x DatabaseUpdateRequestMessageType) String() string {
	return proto.EnumName(DatabaseUpdateRequestMessageType_name, int32(x))
}

func (DatabaseUpdateRequestMessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{2}
}

type EchoRequest struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EchoRequest) Reset()         { *m = EchoRequest{} }
func (m *EchoRequest) String() string { return proto.CompactTextString(m) }
func (*EchoRequest) ProtoMessage()    {}
func (*EchoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{0}
}

func (m *EchoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EchoRequest.Unmarshal(m, b)
}
func (m *EchoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EchoRequest.Marshal(b, m, deterministic)
}
func (m *EchoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EchoRequest.Merge(m, src)
}
func (m *EchoRequest) XXX_Size() int {
	return xxx_messageInfo_EchoRequest.Size(m)
}
func (m *EchoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EchoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EchoRequest proto.InternalMessageInfo

func (m *EchoRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// EchoResponse is the response for echo.
type EchoResponse struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EchoResponse) Reset()         { *m = EchoResponse{} }
func (m *EchoResponse) String() string { return proto.CompactTextString(m) }
func (*EchoResponse) ProtoMessage()    {}
func (*EchoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{1}
}

func (m *EchoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EchoResponse.Unmarshal(m, b)
}
func (m *EchoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EchoResponse.Marshal(b, m, deterministic)
}
func (m *EchoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EchoResponse.Merge(m, src)
}
func (m *EchoResponse) XXX_Size() int {
	return xxx_messageInfo_EchoResponse.Size(m)
}
func (m *EchoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EchoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EchoResponse proto.InternalMessageInfo

func (m *EchoResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DatabaseUpdateVertexMessage struct {
	MessageType          DatabaseUpdateRequestMessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=nmonlistenerapi.DatabaseUpdateRequestMessageType" json:"messageType,omitempty"`
	Dbid                 int64                            `protobuf:"varint,2,opt,name=dbid,proto3" json:"dbid,omitempty"`
	Probs                map[string]string                `protobuf:"bytes,11,rep,name=probs,proto3" json:"probs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DatabaseUpdateVertexMessage) Reset()         { *m = DatabaseUpdateVertexMessage{} }
func (m *DatabaseUpdateVertexMessage) String() string { return proto.CompactTextString(m) }
func (*DatabaseUpdateVertexMessage) ProtoMessage()    {}
func (*DatabaseUpdateVertexMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{2}
}

func (m *DatabaseUpdateVertexMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabaseUpdateVertexMessage.Unmarshal(m, b)
}
func (m *DatabaseUpdateVertexMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabaseUpdateVertexMessage.Marshal(b, m, deterministic)
}
func (m *DatabaseUpdateVertexMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseUpdateVertexMessage.Merge(m, src)
}
func (m *DatabaseUpdateVertexMessage) XXX_Size() int {
	return xxx_messageInfo_DatabaseUpdateVertexMessage.Size(m)
}
func (m *DatabaseUpdateVertexMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseUpdateVertexMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseUpdateVertexMessage proto.InternalMessageInfo

func (m *DatabaseUpdateVertexMessage) GetMessageType() DatabaseUpdateRequestMessageType {
	if m != nil {
		return m.MessageType
	}
	return DatabaseUpdateRequestMessageType_UPDATESTATUS
}

func (m *DatabaseUpdateVertexMessage) GetDbid() int64 {
	if m != nil {
		return m.Dbid
	}
	return 0
}

func (m *DatabaseUpdateVertexMessage) GetProbs() map[string]string {
	if m != nil {
		return m.Probs
	}
	return nil
}

type DatabaseUpdateEdgeMessage struct {
	MessageType          DatabaseUpdateRequestMessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=nmonlistenerapi.DatabaseUpdateRequestMessageType" json:"messageType,omitempty"`
	Dbid                 int64                            `protobuf:"varint,2,opt,name=dbid,proto3" json:"dbid,omitempty"`
	Probs                map[string]string                `protobuf:"bytes,11,rep,name=probs,proto3" json:"probs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DatabaseUpdateEdgeMessage) Reset()         { *m = DatabaseUpdateEdgeMessage{} }
func (m *DatabaseUpdateEdgeMessage) String() string { return proto.CompactTextString(m) }
func (*DatabaseUpdateEdgeMessage) ProtoMessage()    {}
func (*DatabaseUpdateEdgeMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{3}
}

func (m *DatabaseUpdateEdgeMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabaseUpdateEdgeMessage.Unmarshal(m, b)
}
func (m *DatabaseUpdateEdgeMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabaseUpdateEdgeMessage.Marshal(b, m, deterministic)
}
func (m *DatabaseUpdateEdgeMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseUpdateEdgeMessage.Merge(m, src)
}
func (m *DatabaseUpdateEdgeMessage) XXX_Size() int {
	return xxx_messageInfo_DatabaseUpdateEdgeMessage.Size(m)
}
func (m *DatabaseUpdateEdgeMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseUpdateEdgeMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseUpdateEdgeMessage proto.InternalMessageInfo

func (m *DatabaseUpdateEdgeMessage) GetMessageType() DatabaseUpdateRequestMessageType {
	if m != nil {
		return m.MessageType
	}
	return DatabaseUpdateRequestMessageType_UPDATESTATUS
}

func (m *DatabaseUpdateEdgeMessage) GetDbid() int64 {
	if m != nil {
		return m.Dbid
	}
	return 0
}

func (m *DatabaseUpdateEdgeMessage) GetProbs() map[string]string {
	if m != nil {
		return m.Probs
	}
	return nil
}

type Topo struct {
	TopoType             TopoType        `protobuf:"varint,1,opt,name=topoType,proto3,enum=nmonlistenerapi.TopoType" json:"topoType,omitempty"`
	Filter               int64           `protobuf:"varint,2,opt,name=filter,proto3" json:"filter,omitempty"`
	Nodes                map[int64]*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Links                map[int64]*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Topo) Reset()         { *m = Topo{} }
func (m *Topo) String() string { return proto.CompactTextString(m) }
func (*Topo) ProtoMessage()    {}
func (*Topo) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{4}
}

func (m *Topo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Topo.Unmarshal(m, b)
}
func (m *Topo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Topo.Marshal(b, m, deterministic)
}
func (m *Topo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Topo.Merge(m, src)
}
func (m *Topo) XXX_Size() int {
	return xxx_messageInfo_Topo.Size(m)
}
func (m *Topo) XXX_DiscardUnknown() {
	xxx_messageInfo_Topo.DiscardUnknown(m)
}

var xxx_messageInfo_Topo proto.InternalMessageInfo

func (m *Topo) GetTopoType() TopoType {
	if m != nil {
		return m.TopoType
	}
	return TopoType_COUNTRY
}

func (m *Topo) GetFilter() int64 {
	if m != nil {
		return m.Filter
	}
	return 0
}

func (m *Topo) GetNodes() map[int64]*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Topo) GetLinks() map[int64]*Link {
	if m != nil {
		return m.Links
	}
	return nil
}

type DatabaseIgpNodeUpdateRequest struct {
	MessageType          DatabaseUpdateRequestMessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=nmonlistenerapi.DatabaseUpdateRequestMessageType" json:"messageType,omitempty"`
	Dbid                 int64                            `protobuf:"varint,2,opt,name=dbid,proto3" json:"dbid,omitempty"`
	Status               int64                            `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
	Name                 string                           `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	X                    float64                          `protobuf:"fixed64,5,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float64                          `protobuf:"fixed64,6,opt,name=y,proto3" json:"y,omitempty"`
	Popid                int64                            `protobuf:"varint,7,opt,name=popid,proto3" json:"popid,omitempty"`
	IgpRouterId          string                           `protobuf:"bytes,8,opt,name=igpRouterId,proto3" json:"igpRouterId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DatabaseIgpNodeUpdateRequest) Reset()         { *m = DatabaseIgpNodeUpdateRequest{} }
func (m *DatabaseIgpNodeUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*DatabaseIgpNodeUpdateRequest) ProtoMessage()    {}
func (*DatabaseIgpNodeUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{5}
}

func (m *DatabaseIgpNodeUpdateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabaseIgpNodeUpdateRequest.Unmarshal(m, b)
}
func (m *DatabaseIgpNodeUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabaseIgpNodeUpdateRequest.Marshal(b, m, deterministic)
}
func (m *DatabaseIgpNodeUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseIgpNodeUpdateRequest.Merge(m, src)
}
func (m *DatabaseIgpNodeUpdateRequest) XXX_Size() int {
	return xxx_messageInfo_DatabaseIgpNodeUpdateRequest.Size(m)
}
func (m *DatabaseIgpNodeUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseIgpNodeUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseIgpNodeUpdateRequest proto.InternalMessageInfo

func (m *DatabaseIgpNodeUpdateRequest) GetMessageType() DatabaseUpdateRequestMessageType {
	if m != nil {
		return m.MessageType
	}
	return DatabaseUpdateRequestMessageType_UPDATESTATUS
}

func (m *DatabaseIgpNodeUpdateRequest) GetDbid() int64 {
	if m != nil {
		return m.Dbid
	}
	return 0
}

func (m *DatabaseIgpNodeUpdateRequest) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DatabaseIgpNodeUpdateRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabaseIgpNodeUpdateRequest) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *DatabaseIgpNodeUpdateRequest) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *DatabaseIgpNodeUpdateRequest) GetPopid() int64 {
	if m != nil {
		return m.Popid
	}
	return 0
}

func (m *DatabaseIgpNodeUpdateRequest) GetIgpRouterId() string {
	if m != nil {
		return m.IgpRouterId
	}
	return ""
}

type DatabasePopUpdateRequest struct {
	MessageType          DatabaseUpdateRequestMessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=nmonlistenerapi.DatabaseUpdateRequestMessageType" json:"messageType,omitempty"`
	Dbid                 int64                            `protobuf:"varint,2,opt,name=dbid,proto3" json:"dbid,omitempty"`
	PopId                int64                            `protobuf:"varint,3,opt,name=popId,proto3" json:"popId,omitempty"`
	Status               int64                            `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty"`
	Name                 string                           `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	X                    float64                          `protobuf:"fixed64,6,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float64                          `protobuf:"fixed64,7,opt,name=y,proto3" json:"y,omitempty"`
	Cityid               int64                            `protobuf:"varint,8,opt,name=cityid,proto3" json:"cityid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DatabasePopUpdateRequest) Reset()         { *m = DatabasePopUpdateRequest{} }
func (m *DatabasePopUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*DatabasePopUpdateRequest) ProtoMessage()    {}
func (*DatabasePopUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{6}
}

func (m *DatabasePopUpdateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabasePopUpdateRequest.Unmarshal(m, b)
}
func (m *DatabasePopUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabasePopUpdateRequest.Marshal(b, m, deterministic)
}
func (m *DatabasePopUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabasePopUpdateRequest.Merge(m, src)
}
func (m *DatabasePopUpdateRequest) XXX_Size() int {
	return xxx_messageInfo_DatabasePopUpdateRequest.Size(m)
}
func (m *DatabasePopUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabasePopUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DatabasePopUpdateRequest proto.InternalMessageInfo

func (m *DatabasePopUpdateRequest) GetMessageType() DatabaseUpdateRequestMessageType {
	if m != nil {
		return m.MessageType
	}
	return DatabaseUpdateRequestMessageType_UPDATESTATUS
}

func (m *DatabasePopUpdateRequest) GetDbid() int64 {
	if m != nil {
		return m.Dbid
	}
	return 0
}

func (m *DatabasePopUpdateRequest) GetPopId() int64 {
	if m != nil {
		return m.PopId
	}
	return 0
}

func (m *DatabasePopUpdateRequest) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DatabasePopUpdateRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabasePopUpdateRequest) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *DatabasePopUpdateRequest) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *DatabasePopUpdateRequest) GetCityid() int64 {
	if m != nil {
		return m.Cityid
	}
	return 0
}

type DatabaseCityUpdateRequest struct {
	MessageType          DatabaseUpdateRequestMessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=nmonlistenerapi.DatabaseUpdateRequestMessageType" json:"messageType,omitempty"`
	Dbid                 int64                            `protobuf:"varint,2,opt,name=dbid,proto3" json:"dbid,omitempty"`
	CityId               int64                            `protobuf:"varint,3,opt,name=cityId,proto3" json:"cityId,omitempty"`
	Status               int64                            `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty"`
	Name                 string                           `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	X                    float64                          `protobuf:"fixed64,6,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float64                          `protobuf:"fixed64,7,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DatabaseCityUpdateRequest) Reset()         { *m = DatabaseCityUpdateRequest{} }
func (m *DatabaseCityUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*DatabaseCityUpdateRequest) ProtoMessage()    {}
func (*DatabaseCityUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{7}
}

func (m *DatabaseCityUpdateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabaseCityUpdateRequest.Unmarshal(m, b)
}
func (m *DatabaseCityUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabaseCityUpdateRequest.Marshal(b, m, deterministic)
}
func (m *DatabaseCityUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseCityUpdateRequest.Merge(m, src)
}
func (m *DatabaseCityUpdateRequest) XXX_Size() int {
	return xxx_messageInfo_DatabaseCityUpdateRequest.Size(m)
}
func (m *DatabaseCityUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseCityUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseCityUpdateRequest proto.InternalMessageInfo

func (m *DatabaseCityUpdateRequest) GetMessageType() DatabaseUpdateRequestMessageType {
	if m != nil {
		return m.MessageType
	}
	return DatabaseUpdateRequestMessageType_UPDATESTATUS
}

func (m *DatabaseCityUpdateRequest) GetDbid() int64 {
	if m != nil {
		return m.Dbid
	}
	return 0
}

func (m *DatabaseCityUpdateRequest) GetCityId() int64 {
	if m != nil {
		return m.CityId
	}
	return 0
}

func (m *DatabaseCityUpdateRequest) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DatabaseCityUpdateRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabaseCityUpdateRequest) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *DatabaseCityUpdateRequest) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

type DatabaseLinkUpdateMessage struct {
	MessageType          DatabaseUpdateRequestMessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=nmonlistenerapi.DatabaseUpdateRequestMessageType" json:"messageType,omitempty"`
	Dbid                 int64                            `protobuf:"varint,2,opt,name=dbid,proto3" json:"dbid,omitempty"`
	Status               int64                            `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DatabaseLinkUpdateMessage) Reset()         { *m = DatabaseLinkUpdateMessage{} }
func (m *DatabaseLinkUpdateMessage) String() string { return proto.CompactTextString(m) }
func (*DatabaseLinkUpdateMessage) ProtoMessage()    {}
func (*DatabaseLinkUpdateMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{8}
}

func (m *DatabaseLinkUpdateMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatabaseLinkUpdateMessage.Unmarshal(m, b)
}
func (m *DatabaseLinkUpdateMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatabaseLinkUpdateMessage.Marshal(b, m, deterministic)
}
func (m *DatabaseLinkUpdateMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseLinkUpdateMessage.Merge(m, src)
}
func (m *DatabaseLinkUpdateMessage) XXX_Size() int {
	return xxx_messageInfo_DatabaseLinkUpdateMessage.Size(m)
}
func (m *DatabaseLinkUpdateMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseLinkUpdateMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseLinkUpdateMessage proto.InternalMessageInfo

func (m *DatabaseLinkUpdateMessage) GetMessageType() DatabaseUpdateRequestMessageType {
	if m != nil {
		return m.MessageType
	}
	return DatabaseUpdateRequestMessageType_UPDATESTATUS
}

func (m *DatabaseLinkUpdateMessage) GetDbid() int64 {
	if m != nil {
		return m.Dbid
	}
	return 0
}

func (m *DatabaseLinkUpdateMessage) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

type Node struct {
	Id                   int64             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Status               int64             `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	Name                 string            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Label                string            `protobuf:"bytes,4,opt,name=label,proto3" json:"label,omitempty"`
	Boundary             bool              `protobuf:"varint,5,opt,name=boundary,proto3" json:"boundary,omitempty"`
	Probs                map[string]string `protobuf:"bytes,6,rep,name=probs,proto3" json:"probs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{9}
}

func (m *Node) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Node.Unmarshal(m, b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Node.Marshal(b, m, deterministic)
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return xxx_messageInfo_Node.Size(m)
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Node) GetBoundary() bool {
	if m != nil {
		return m.Boundary
	}
	return false
}

func (m *Node) GetProbs() map[string]string {
	if m != nil {
		return m.Probs
	}
	return nil
}

type Link struct {
	Id                   int64             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Status               int64             `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	SourceNode           int64             `protobuf:"varint,3,opt,name=sourceNode,proto3" json:"sourceNode,omitempty"`
	TargetNode           int64             `protobuf:"varint,4,opt,name=targetNode,proto3" json:"targetNode,omitempty"`
	Probs                map[string]string `protobuf:"bytes,5,rep,name=probs,proto3" json:"probs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{10}
}

func (m *Link) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link.Unmarshal(m, b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link.Marshal(b, m, deterministic)
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return xxx_messageInfo_Link.Size(m)
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Link) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Link) GetSourceNode() int64 {
	if m != nil {
		return m.SourceNode
	}
	return 0
}

func (m *Link) GetTargetNode() int64 {
	if m != nil {
		return m.TargetNode
	}
	return 0
}

func (m *Link) GetProbs() map[string]string {
	if m != nil {
		return m.Probs
	}
	return nil
}

type IgpNode struct {
	DbId                 uint32   `protobuf:"varint,1,opt,name=dbId,proto3" json:"dbId,omitempty"`
	Status               Status   `protobuf:"varint,2,opt,name=status,proto3,enum=nmonlistenerapi.Status" json:"status,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Asn                  uint32   `protobuf:"varint,4,opt,name=asn,proto3" json:"asn,omitempty"`
	BgpLsInstanceId      uint32   `protobuf:"varint,5,opt,name=bgpLsInstanceId,proto3" json:"bgpLsInstanceId,omitempty"`
	IgpRouterId          string   `protobuf:"bytes,6,opt,name=igpRouterId,proto3" json:"igpRouterId,omitempty"`
	RouterId             string   `protobuf:"bytes,7,opt,name=routerId,proto3" json:"routerId,omitempty"`
	RouterIdV6           string   `protobuf:"bytes,8,opt,name=routerIdV6,proto3" json:"routerIdV6,omitempty"`
	IsisArea             uint32   `protobuf:"varint,9,opt,name=isisArea,proto3" json:"isisArea,omitempty"`
	IPv4SRCapable        bool     `protobuf:"varint,10,opt,name=iPv4SRCapable,proto3" json:"iPv4SRCapable,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IgpNode) Reset()         { *m = IgpNode{} }
func (m *IgpNode) String() string { return proto.CompactTextString(m) }
func (*IgpNode) ProtoMessage()    {}
func (*IgpNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{11}
}

func (m *IgpNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IgpNode.Unmarshal(m, b)
}
func (m *IgpNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IgpNode.Marshal(b, m, deterministic)
}
func (m *IgpNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IgpNode.Merge(m, src)
}
func (m *IgpNode) XXX_Size() int {
	return xxx_messageInfo_IgpNode.Size(m)
}
func (m *IgpNode) XXX_DiscardUnknown() {
	xxx_messageInfo_IgpNode.DiscardUnknown(m)
}

var xxx_messageInfo_IgpNode proto.InternalMessageInfo

func (m *IgpNode) GetDbId() uint32 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *IgpNode) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_UP
}

func (m *IgpNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IgpNode) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *IgpNode) GetBgpLsInstanceId() uint32 {
	if m != nil {
		return m.BgpLsInstanceId
	}
	return 0
}

func (m *IgpNode) GetIgpRouterId() string {
	if m != nil {
		return m.IgpRouterId
	}
	return ""
}

func (m *IgpNode) GetRouterId() string {
	if m != nil {
		return m.RouterId
	}
	return ""
}

func (m *IgpNode) GetRouterIdV6() string {
	if m != nil {
		return m.RouterIdV6
	}
	return ""
}

func (m *IgpNode) GetIsisArea() uint32 {
	if m != nil {
		return m.IsisArea
	}
	return 0
}

func (m *IgpNode) GetIPv4SRCapable() bool {
	if m != nil {
		return m.IPv4SRCapable
	}
	return false
}

type IgpLink struct {
	DbId                  uint32   `protobuf:"varint,1,opt,name=dbId,proto3" json:"dbId,omitempty"`
	Status                Status   `protobuf:"varint,2,opt,name=status,proto3,enum=nmonlistenerapi.Status" json:"status,omitempty"`
	LocalAsn              uint32   `protobuf:"varint,3,opt,name=localAsn,proto3" json:"localAsn,omitempty"`
	LocalBgpLsInstanceId  uint32   `protobuf:"varint,4,opt,name=localBgpLsInstanceId,proto3" json:"localBgpLsInstanceId,omitempty"`
	LocalIgpRouterId      string   `protobuf:"bytes,5,opt,name=localIgpRouterId,proto3" json:"localIgpRouterId,omitempty"`
	RemoteAsn             uint32   `protobuf:"varint,6,opt,name=remoteAsn,proto3" json:"remoteAsn,omitempty"`
	RemoteBgpLsInstanceId uint32   `protobuf:"varint,7,opt,name=remoteBgpLsInstanceId,proto3" json:"remoteBgpLsInstanceId,omitempty"`
	RemoteIgpRouterId     string   `protobuf:"bytes,8,opt,name=remoteIgpRouterId,proto3" json:"remoteIgpRouterId,omitempty"`
	IgpInterfaceIp        string   `protobuf:"bytes,9,opt,name=igpInterfaceIp,proto3" json:"igpInterfaceIp,omitempty"`
	RemoteNeighborIp      string   `protobuf:"bytes,10,opt,name=remoteNeighborIp,proto3" json:"remoteNeighborIp,omitempty"`
	IgpInterfaceIpv6      string   `protobuf:"bytes,11,opt,name=igpInterfaceIpv6,proto3" json:"igpInterfaceIpv6,omitempty"`
	RemoteNeighborIpv6    string   `protobuf:"bytes,12,opt,name=remoteNeighborIpv6,proto3" json:"remoteNeighborIpv6,omitempty"`
	LocalRouterId         string   `protobuf:"bytes,13,opt,name=localRouterId,proto3" json:"localRouterId,omitempty"`
	LocalRouterIdV6       string   `protobuf:"bytes,14,opt,name=localRouterIdV6,proto3" json:"localRouterIdV6,omitempty"`
	Bandwidth             float32  `protobuf:"fixed32,15,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	IgpMetric             uint32   `protobuf:"varint,16,opt,name=igpMetric,proto3" json:"igpMetric,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *IgpLink) Reset()         { *m = IgpLink{} }
func (m *IgpLink) String() string { return proto.CompactTextString(m) }
func (*IgpLink) ProtoMessage()    {}
func (*IgpLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_90d83fe8ca7a920c, []int{12}
}

func (m *IgpLink) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IgpLink.Unmarshal(m, b)
}
func (m *IgpLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IgpLink.Marshal(b, m, deterministic)
}
func (m *IgpLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IgpLink.Merge(m, src)
}
func (m *IgpLink) XXX_Size() int {
	return xxx_messageInfo_IgpLink.Size(m)
}
func (m *IgpLink) XXX_DiscardUnknown() {
	xxx_messageInfo_IgpLink.DiscardUnknown(m)
}

var xxx_messageInfo_IgpLink proto.InternalMessageInfo

func (m *IgpLink) GetDbId() uint32 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *IgpLink) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_UP
}

func (m *IgpLink) GetLocalAsn() uint32 {
	if m != nil {
		return m.LocalAsn
	}
	return 0
}

func (m *IgpLink) GetLocalBgpLsInstanceId() uint32 {
	if m != nil {
		return m.LocalBgpLsInstanceId
	}
	return 0
}

func (m *IgpLink) GetLocalIgpRouterId() string {
	if m != nil {
		return m.LocalIgpRouterId
	}
	return ""
}

func (m *IgpLink) GetRemoteAsn() uint32 {
	if m != nil {
		return m.RemoteAsn
	}
	return 0
}

func (m *IgpLink) GetRemoteBgpLsInstanceId() uint32 {
	if m != nil {
		return m.RemoteBgpLsInstanceId
	}
	return 0
}

func (m *IgpLink) GetRemoteIgpRouterId() string {
	if m != nil {
		return m.RemoteIgpRouterId
	}
	return ""
}

func (m *IgpLink) GetIgpInterfaceIp() string {
	if m != nil {
		return m.IgpInterfaceIp
	}
	return ""
}

func (m *IgpLink) GetRemoteNeighborIp() string {
	if m != nil {
		return m.RemoteNeighborIp
	}
	return ""
}

func (m *IgpLink) GetIgpInterfaceIpv6() string {
	if m != nil {
		return m.IgpInterfaceIpv6
	}
	return ""
}

func (m *IgpLink) GetRemoteNeighborIpv6() string {
	if m != nil {
		return m.RemoteNeighborIpv6
	}
	return ""
}

func (m *IgpLink) GetLocalRouterId() string {
	if m != nil {
		return m.LocalRouterId
	}
	return ""
}

func (m *IgpLink) GetLocalRouterIdV6() string {
	if m != nil {
		return m.LocalRouterIdV6
	}
	return ""
}

func (m *IgpLink) GetBandwidth() float32 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

func (m *IgpLink) GetIgpMetric() uint32 {
	if m != nil {
		return m.IgpMetric
	}
	return 0
}

func init() {
	proto.RegisterEnum("nmonlistenerapi.Status", Status_name, Status_value)
	proto.RegisterEnum("nmonlistenerapi.TopoType", TopoType_name, TopoType_value)
	proto.RegisterEnum("nmonlistenerapi.DatabaseUpdateRequestMessageType", DatabaseUpdateRequestMessageType_name, DatabaseUpdateRequestMessageType_value)
	proto.RegisterType((*EchoRequest)(nil), "nmonlistenerapi.EchoRequest")
	proto.RegisterType((*EchoResponse)(nil), "nmonlistenerapi.EchoResponse")
	proto.RegisterType((*DatabaseUpdateVertexMessage)(nil), "nmonlistenerapi.DatabaseUpdateVertexMessage")
	proto.RegisterMapType((map[string]string)(nil), "nmonlistenerapi.DatabaseUpdateVertexMessage.ProbsEntry")
	proto.RegisterType((*DatabaseUpdateEdgeMessage)(nil), "nmonlistenerapi.DatabaseUpdateEdgeMessage")
	proto.RegisterMapType((map[string]string)(nil), "nmonlistenerapi.DatabaseUpdateEdgeMessage.ProbsEntry")
	proto.RegisterType((*Topo)(nil), "nmonlistenerapi.Topo")
	proto.RegisterMapType((map[int64]*Link)(nil), "nmonlistenerapi.Topo.LinksEntry")
	proto.RegisterMapType((map[int64]*Node)(nil), "nmonlistenerapi.Topo.NodesEntry")
	proto.RegisterType((*DatabaseIgpNodeUpdateRequest)(nil), "nmonlistenerapi.DatabaseIgpNodeUpdateRequest")
	proto.RegisterType((*DatabasePopUpdateRequest)(nil), "nmonlistenerapi.DatabasePopUpdateRequest")
	proto.RegisterType((*DatabaseCityUpdateRequest)(nil), "nmonlistenerapi.DatabaseCityUpdateRequest")
	proto.RegisterType((*DatabaseLinkUpdateMessage)(nil), "nmonlistenerapi.DatabaseLinkUpdateMessage")
	proto.RegisterType((*Node)(nil), "nmonlistenerapi.Node")
	proto.RegisterMapType((map[string]string)(nil), "nmonlistenerapi.Node.ProbsEntry")
	proto.RegisterType((*Link)(nil), "nmonlistenerapi.Link")
	proto.RegisterMapType((map[string]string)(nil), "nmonlistenerapi.Link.ProbsEntry")
	proto.RegisterType((*IgpNode)(nil), "nmonlistenerapi.IgpNode")
	proto.RegisterType((*IgpLink)(nil), "nmonlistenerapi.IgpLink")
}

func init() { proto.RegisterFile("nmonlistenerapi.proto", fileDescriptor_90d83fe8ca7a920c) }

var fileDescriptor_90d83fe8ca7a920c = []byte{
	// 1379 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x5f, 0x73, 0xdb, 0x44,
	0x10, 0xb7, 0xe4, 0xff, 0xeb, 0x24, 0x55, 0xaf, 0x4d, 0x51, 0x45, 0x61, 0x3c, 0x9a, 0x0e, 0x98,
	0x50, 0x42, 0x31, 0x6d, 0x28, 0x3c, 0x91, 0x7f, 0xd3, 0x71, 0xdb, 0x38, 0x9e, 0xb3, 0x93, 0x4e,
	0x9f, 0x18, 0xd9, 0xba, 0xba, 0x37, 0x95, 0x25, 0x21, 0x9d, 0x43, 0xfd, 0x09, 0xe0, 0x43, 0xf0,
	0x0d, 0x78, 0xe0, 0x1b, 0xf0, 0x59, 0x78, 0x60, 0x60, 0x06, 0x3e, 0x01, 0x4f, 0x30, 0x77, 0x27,
	0xd9, 0xb2, 0x65, 0x27, 0x4d, 0xeb, 0xa6, 0x2f, 0x7d, 0xbb, 0xdd, 0xfd, 0xed, 0x6a, 0xf7, 0x77,
	0x7b, 0x2b, 0xe9, 0x60, 0xdd, 0x1d, 0x78, 0xae, 0x43, 0x43, 0x46, 0x5c, 0x12, 0x58, 0x3e, 0xdd,
	0xf4, 0x03, 0x8f, 0x79, 0xe8, 0xd2, 0x8c, 0xda, 0xfc, 0x18, 0x2a, 0xfb, 0xbd, 0x67, 0x1e, 0x26,
	0xdf, 0x0f, 0x49, 0xc8, 0x90, 0x0e, 0xc5, 0x01, 0x09, 0x43, 0xab, 0x4f, 0x74, 0xa5, 0xaa, 0xd4,
	0xca, 0x38, 0x16, 0xcd, 0x1a, 0xac, 0x48, 0x60, 0xe8, 0x7b, 0x6e, 0x48, 0x4e, 0x41, 0xfe, 0xaa,
	0xc2, 0xfb, 0x7b, 0x16, 0xb3, 0xba, 0x56, 0x48, 0x8e, 0x7c, 0xdb, 0x62, 0xe4, 0x98, 0x04, 0x8c,
	0xbc, 0x38, 0x90, 0x76, 0xd4, 0x86, 0x4a, 0x04, 0xed, 0x8c, 0x7c, 0xe9, 0xbd, 0x56, 0xff, 0x62,
	0x73, 0x36, 0xe1, 0xe9, 0x10, 0x51, 0x82, 0x07, 0x13, 0x47, 0x9c, 0x8c, 0x82, 0x10, 0xe4, 0xec,
	0x2e, 0xb5, 0x75, 0xb5, 0xaa, 0xd4, 0xb2, 0x58, 0xac, 0xd1, 0x01, 0xe4, 0xfd, 0xc0, 0xeb, 0x86,
	0x7a, 0xa5, 0x9a, 0xad, 0x55, 0xea, 0x5f, 0x9d, 0xf1, 0x88, 0xa9, 0x2c, 0x37, 0x5b, 0xdc, 0x73,
	0xdf, 0x65, 0xc1, 0x08, 0xcb, 0x28, 0xc6, 0x3d, 0x80, 0x89, 0x12, 0x69, 0x90, 0x7d, 0x4e, 0x46,
	0x51, 0xed, 0x7c, 0x89, 0xae, 0x42, 0xfe, 0xc4, 0x72, 0x86, 0x44, 0xe4, 0x50, 0xc6, 0x52, 0xf8,
	0x46, 0xbd, 0xa7, 0x3c, 0xc8, 0x95, 0xb2, 0x5a, 0x05, 0x17, 0x42, 0x66, 0xb1, 0x61, 0x88, 0x55,
	0x6a, 0xe3, 0xbc, 0x63, 0x75, 0x89, 0x83, 0xf3, 0x03, 0xcf, 0x26, 0x8e, 0xf9, 0x8b, 0x0a, 0xd7,
	0xa7, 0x73, 0xd9, 0xb7, 0xfb, 0xe4, 0xc2, 0xf9, 0x7a, 0x38, 0xcd, 0xd7, 0xdd, 0x33, 0x1e, 0x91,
	0xc8, 0xf1, 0x42, 0xd9, 0xfa, 0x4b, 0x85, 0x5c, 0xc7, 0xf3, 0x3d, 0x74, 0x17, 0x4a, 0xcc, 0xf3,
	0xbd, 0x04, 0x2b, 0xd7, 0x53, 0x29, 0x77, 0x22, 0x00, 0x1e, 0x43, 0xd1, 0x35, 0x28, 0x3c, 0xa5,
	0x0e, 0x23, 0x41, 0x54, 0x7c, 0x24, 0xa1, 0x2d, 0xc8, 0xbb, 0x9e, 0x4d, 0x42, 0x3d, 0x2b, 0xca,
	0xaf, 0xce, 0x8d, 0xb5, 0xd9, 0xe4, 0x90, 0xa8, 0x52, 0x01, 0xe7, 0x7e, 0x0e, 0x75, 0x9f, 0x87,
	0x7a, 0xee, 0x34, 0xbf, 0x47, 0x1c, 0x12, 0xf9, 0x09, 0xb8, 0x71, 0x08, 0x30, 0x09, 0x96, 0x64,
	0x28, 0x2b, 0x19, 0xfa, 0x34, 0xc9, 0x50, 0xa5, 0xbe, 0x9e, 0x8a, 0xcb, 0xbd, 0x13, 0xc4, 0xf1,
	0x80, 0x93, 0xa7, 0xbc, 0x4a, 0x40, 0xee, 0x9d, 0x08, 0x68, 0xfe, 0xa8, 0xc2, 0x8d, 0x78, 0xcf,
	0x1b, 0x7d, 0x9f, 0x3f, 0x6f, 0xaa, 0xbb, 0x2e, 0xae, 0x35, 0xaf, 0x41, 0xd4, 0x0f, 0x7a, 0x56,
	0xee, 0x99, 0x94, 0x38, 0xd6, 0xb5, 0x06, 0x44, 0xcf, 0x89, 0x26, 0x12, 0x6b, 0xb4, 0x02, 0xca,
	0x0b, 0x3d, 0x5f, 0x55, 0x6a, 0x0a, 0x56, 0x5e, 0x70, 0x69, 0xa4, 0x17, 0xa4, 0x24, 0xba, 0xce,
	0xf7, 0x7c, 0x6a, 0xeb, 0x45, 0x11, 0x46, 0x0a, 0xa8, 0x0a, 0x15, 0xda, 0xf7, 0xb1, 0x37, 0x64,
	0x24, 0x68, 0xd8, 0x7a, 0x49, 0x04, 0x4b, 0xaa, 0xcc, 0x7f, 0x15, 0xd0, 0xe3, 0x2a, 0x5a, 0x9e,
	0xff, 0x96, 0x58, 0x90, 0xd9, 0x37, 0xec, 0x88, 0x04, 0x29, 0x24, 0xb8, 0xc9, 0xcd, 0xe5, 0x26,
	0x3f, 0xcb, 0x4d, 0x61, 0x8a, 0x9b, 0x62, 0xcc, 0xcd, 0x35, 0x28, 0xf4, 0x28, 0x1b, 0x51, 0x49,
	0x40, 0x16, 0x47, 0x92, 0xf9, 0x87, 0x32, 0x99, 0x4e, 0xbb, 0x94, 0x8d, 0xde, 0x5e, 0x0b, 0xf0,
	0x84, 0xc6, 0xd5, 0x47, 0xd2, 0xb2, 0xca, 0x37, 0x7f, 0x4e, 0x94, 0xc9, 0x0f, 0x82, 0xcc, 0xf4,
	0xc2, 0x87, 0xf0, 0x82, 0x4e, 0x37, 0xff, 0x54, 0x20, 0xc7, 0x0f, 0x20, 0x5a, 0x03, 0x95, 0xda,
	0xd1, 0xb1, 0x56, 0xa7, 0x1c, 0xd4, 0xb9, 0xf5, 0x67, 0x13, 0xf5, 0x5f, 0x05, 0x39, 0x4a, 0xa3,
	0xf3, 0x22, 0x05, 0x64, 0x40, 0xa9, 0xeb, 0x0d, 0x5d, 0xdb, 0x0a, 0x46, 0x82, 0xad, 0x12, 0x1e,
	0xcb, 0x7c, 0xb8, 0xc9, 0x77, 0x42, 0x61, 0xc1, 0x70, 0xe3, 0x39, 0x2d, 0x73, 0xfc, 0x9b, 0xbf,
	0x2b, 0x90, 0xe3, 0xfc, 0xbf, 0x74, 0xa1, 0x1f, 0x02, 0x84, 0xde, 0x30, 0xe8, 0x11, 0x9e, 0x4a,
	0xc4, 0x5a, 0x42, 0xc3, 0xed, 0xcc, 0x0a, 0xfa, 0x84, 0x09, 0xbb, 0x6c, 0x92, 0x84, 0x66, 0x52,
	0x62, 0x7e, 0x41, 0x89, 0x3c, 0x9b, 0xa5, 0x96, 0xf8, 0x9b, 0x0a, 0xc5, 0x68, 0x9e, 0xca, 0x1e,
	0x68, 0xc8, 0x3a, 0x57, 0xb1, 0x58, 0xa3, 0xcf, 0xa7, 0x2a, 0x5d, 0xab, 0xbf, 0x97, 0x4a, 0xa9,
	0x2d, 0x5f, 0x8e, 0xa7, 0xed, 0xb5, 0x06, 0x59, 0x2b, 0x74, 0x45, 0xbd, 0xab, 0x98, 0x2f, 0x51,
	0x0d, 0x2e, 0x75, 0xfb, 0xfe, 0xa3, 0xb0, 0xe1, 0x86, 0xcc, 0x72, 0x7b, 0xa4, 0x61, 0x8b, 0xed,
	0x5e, 0xc5, 0xb3, 0xea, 0xd9, 0x81, 0x58, 0x48, 0x0d, 0x44, 0xde, 0x33, 0x41, 0x6c, 0x2e, 0x0a,
	0xf3, 0x58, 0xe6, 0x84, 0xc7, 0xeb, 0xe3, 0xad, 0x68, 0x9a, 0x26, 0x34, 0xdc, 0x97, 0x86, 0x34,
	0xdc, 0x0e, 0x88, 0xa5, 0x97, 0x45, 0x02, 0x63, 0x19, 0xdd, 0x84, 0x55, 0xda, 0x3a, 0xb9, 0xd3,
	0xc6, 0xbb, 0x96, 0x6f, 0x75, 0x1d, 0xa2, 0x83, 0x68, 0xc8, 0x69, 0xa5, 0xf9, 0x53, 0x5e, 0x10,
	0x28, 0xda, 0x64, 0x29, 0x04, 0x1a, 0x50, 0x72, 0xbc, 0x9e, 0xe5, 0x6c, 0x87, 0xae, 0x20, 0x71,
	0x15, 0x8f, 0x65, 0x54, 0x87, 0xab, 0x62, 0xbd, 0x33, 0xc3, 0x9d, 0x64, 0x76, 0xae, 0x0d, 0x6d,
	0x80, 0x26, 0xf4, 0x8d, 0x04, 0x8b, 0x72, 0x10, 0xa5, 0xf4, 0xe8, 0x06, 0x94, 0x03, 0x32, 0xf0,
	0x18, 0xe1, 0x0f, 0x2f, 0x88, 0xa0, 0x13, 0x05, 0xba, 0x03, 0xeb, 0x52, 0x98, 0x7d, 0x7c, 0x51,
	0x20, 0xe7, 0x1b, 0xd1, 0x2d, 0xb8, 0x2c, 0x0d, 0x8d, 0xd4, 0x7b, 0x2d, 0x6d, 0x40, 0x1f, 0xc1,
	0x1a, 0xed, 0xfb, 0x0d, 0x97, 0x91, 0xe0, 0xa9, 0xd5, 0x23, 0x0d, 0x5f, 0x6c, 0x4b, 0x19, 0xcf,
	0x68, 0x79, 0x55, 0xd2, 0xb9, 0x49, 0x68, 0xff, 0x59, 0xd7, 0x0b, 0x1a, 0xbe, 0xd8, 0x9f, 0x32,
	0x4e, 0xe9, 0x39, 0x76, 0xda, 0xfb, 0x64, 0x4b, 0xaf, 0x48, 0xec, 0xac, 0x1e, 0x6d, 0x02, 0x9a,
	0xf5, 0x3f, 0xd9, 0xd2, 0x57, 0x04, 0x7a, 0x8e, 0x85, 0x37, 0x89, 0x60, 0x71, 0x5c, 0xd9, 0xaa,
	0x80, 0x4e, 0x2b, 0x79, 0xbb, 0x4f, 0x29, 0x8e, 0xb7, 0xf4, 0x35, 0x81, 0x9b, 0x55, 0xf3, 0x1d,
	0xe8, 0x5a, 0xae, 0xfd, 0x03, 0xb5, 0xd9, 0x33, 0xfd, 0x52, 0x55, 0xa9, 0xa9, 0x78, 0xa2, 0xe0,
	0x56, 0xda, 0xf7, 0x0f, 0x08, 0x0b, 0x68, 0x4f, 0xd7, 0xe4, 0xfe, 0x8c, 0x15, 0x1b, 0x37, 0xa1,
	0x20, 0x7b, 0x09, 0x15, 0x40, 0x3d, 0x6a, 0x69, 0x19, 0x54, 0x82, 0xdc, 0xe3, 0x6d, 0xdc, 0xd4,
	0x14, 0xbe, 0xda, 0x3b, 0x7c, 0xdc, 0xd4, 0xd4, 0x8d, 0x0d, 0x28, 0xc5, 0x5f, 0xa2, 0xa8, 0x02,
	0xc5, 0xdd, 0xc3, 0xa3, 0x66, 0x07, 0x3f, 0x91, 0xe0, 0xdd, 0x46, 0xe7, 0x89, 0xa6, 0xa0, 0x22,
	0x64, 0x5b, 0x87, 0x2d, 0x4d, 0xdd, 0x78, 0x08, 0xd5, 0xb3, 0x5e, 0x23, 0x48, 0x83, 0x95, 0xa3,
	0xd6, 0xde, 0x76, 0x67, 0xbf, 0xdd, 0xd9, 0xee, 0x1c, 0xb5, 0xb5, 0x0c, 0x5a, 0x87, 0xcb, 0x52,
	0xb3, 0x7b, 0x78, 0x88, 0xf7, 0x1a, 0x4d, 0x6e, 0xd3, 0x94, 0xfa, 0x7f, 0x39, 0xd0, 0x9a, 0x03,
	0xcf, 0xdd, 0xb9, 0xdf, 0x7a, 0xd4, 0x6e, 0x93, 0xe0, 0x84, 0xf6, 0x08, 0xda, 0x01, 0x68, 0x13,
	0x16, 0x4f, 0x20, 0x3d, 0x75, 0x38, 0x22, 0x8b, 0xb1, 0xd0, 0x62, 0x66, 0x26, 0x31, 0xc4, 0x21,
	0x9c, 0x8b, 0xe4, 0x16, 0x63, 0xa1, 0x45, 0xc6, 0xd8, 0xb6, 0xed, 0xd7, 0xce, 0x43, 0xc6, 0x78,
	0x8d, 0x3c, 0x1e, 0x40, 0xf9, 0xc8, 0xb5, 0x82, 0x11, 0xff, 0xc1, 0x45, 0x37, 0x52, 0xc0, 0xc4,
	0x0f, 0xb2, 0xf1, 0xc1, 0x02, 0xab, 0xfc, 0x2b, 0x36, 0x33, 0xe8, 0x18, 0xae, 0x70, 0x9a, 0x49,
	0xd0, 0x66, 0x01, 0xb1, 0x06, 0xd4, 0xed, 0x2f, 0x21, 0xea, 0x6d, 0x85, 0xc7, 0xdd, 0x75, 0x28,
	0x71, 0xd9, 0x32, 0xe3, 0xd6, 0x14, 0xf4, 0x1d, 0x18, 0x3b, 0xd4, 0xa6, 0x01, 0xe9, 0x31, 0xea,
	0xb9, 0x96, 0xb3, 0xdc, 0xf0, 0xb7, 0x95, 0xfa, 0x3f, 0x45, 0xb8, 0xc2, 0x3b, 0x30, 0xee, 0xe9,
	0xb8, 0x09, 0x9f, 0x02, 0xc8, 0xf6, 0xe6, 0xdf, 0x94, 0x68, 0x63, 0xe1, 0xa7, 0x54, 0xea, 0x93,
	0xd3, 0x38, 0x07, 0xd6, 0xcc, 0xa0, 0x1e, 0x94, 0xa5, 0xaa, 0xe5, 0xf9, 0xe8, 0x93, 0x85, 0xae,
	0xb3, 0x5f, 0xf5, 0xc6, 0xcb, 0x43, 0xcd, 0x0c, 0x72, 0xe2, 0x62, 0x44, 0x27, 0x7f, 0xb6, 0xd0,
	0x75, 0xde, 0x5f, 0x94, 0x71, 0x3e, 0xb8, 0x99, 0x99, 0x50, 0x27, 0x7a, 0x7e, 0x31, 0x1d, 0xa9,
	0xcf, 0x58, 0xe3, 0x1c, 0x58, 0x51, 0xd5, 0x4a, 0xf2, 0x6a, 0x04, 0xdd, 0x3a, 0xcf, 0x0d, 0x8a,
	0x71, 0x2e, 0x74, 0xb2, 0xaa, 0x7d, 0xbb, 0x4f, 0x4e, 0xa9, 0x2a, 0x75, 0xfb, 0x60, 0x9c, 0x03,
	0xfb, 0xee, 0xb4, 0xbf, 0xd9, 0xd3, 0xfe, 0x77, 0x16, 0xd6, 0xf8, 0x69, 0xbf, 0x3f, 0xa4, 0xf1,
	0x41, 0xff, 0x1a, 0x8a, 0xf7, 0x09, 0x13, 0x37, 0x36, 0xeb, 0x73, 0xef, 0x46, 0x8c, 0xf9, 0x6a,
	0x33, 0x83, 0xbe, 0x8d, 0x5b, 0xe2, 0x55, 0xbc, 0x79, 0x3e, 0xef, 0x36, 0xfb, 0x0d, 0x6e, 0x76,
	0xb7, 0x20, 0x2e, 0x95, 0xbf, 0xfc, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x80, 0x61, 0xe1, 0xc0, 0x6d,
	0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NmonBGPLSServiceClient is the client API for NmonBGPLSService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NmonBGPLSServiceClient interface {
	SetIgpNode(ctx context.Context, in *IgpNode, opts ...grpc.CallOption) (*IgpNode, error)
	SetIgpLink(ctx context.Context, in *IgpLink, opts ...grpc.CallOption) (*IgpLink, error)
	AddIgpNode(ctx context.Context, in *IgpNode, opts ...grpc.CallOption) (*IgpNode, error)
	AddIgpLink(ctx context.Context, in *IgpLink, opts ...grpc.CallOption) (*IgpLink, error)
	// UnaryEcho is unary echo.
	UnaryEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	// ServerStreamingEcho is server side streaming.
	ServerStreamingEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (NmonBGPLSService_ServerStreamingEchoClient, error)
	// ClientStreamingEcho is client side streaming.
	ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonBGPLSService_ClientStreamingEchoClient, error)
	// BidirectionalStreamingEcho is bidir streaming.
	BidirectionalStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonBGPLSService_BidirectionalStreamingEchoClient, error)
}

type nmonBGPLSServiceClient struct {
	cc *grpc.ClientConn
}

func NewNmonBGPLSServiceClient(cc *grpc.ClientConn) NmonBGPLSServiceClient {
	return &nmonBGPLSServiceClient{cc}
}

func (c *nmonBGPLSServiceClient) SetIgpNode(ctx context.Context, in *IgpNode, opts ...grpc.CallOption) (*IgpNode, error) {
	out := new(IgpNode)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonBGPLSService/SetIgpNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonBGPLSServiceClient) SetIgpLink(ctx context.Context, in *IgpLink, opts ...grpc.CallOption) (*IgpLink, error) {
	out := new(IgpLink)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonBGPLSService/SetIgpLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonBGPLSServiceClient) AddIgpNode(ctx context.Context, in *IgpNode, opts ...grpc.CallOption) (*IgpNode, error) {
	out := new(IgpNode)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonBGPLSService/AddIgpNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonBGPLSServiceClient) AddIgpLink(ctx context.Context, in *IgpLink, opts ...grpc.CallOption) (*IgpLink, error) {
	out := new(IgpLink)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonBGPLSService/AddIgpLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonBGPLSServiceClient) UnaryEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonBGPLSService/UnaryEcho", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonBGPLSServiceClient) ServerStreamingEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (NmonBGPLSService_ServerStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonBGPLSService_serviceDesc.Streams[0], "/nmonlistenerapi.NmonBGPLSService/ServerStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonBGPLSServiceServerStreamingEchoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NmonBGPLSService_ServerStreamingEchoClient interface {
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonBGPLSServiceServerStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonBGPLSServiceServerStreamingEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nmonBGPLSServiceClient) ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonBGPLSService_ClientStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonBGPLSService_serviceDesc.Streams[1], "/nmonlistenerapi.NmonBGPLSService/ClientStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonBGPLSServiceClientStreamingEchoClient{stream}
	return x, nil
}

type NmonBGPLSService_ClientStreamingEchoClient interface {
	Send(*EchoRequest) error
	CloseAndRecv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonBGPLSServiceClientStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonBGPLSServiceClientStreamingEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nmonBGPLSServiceClientStreamingEchoClient) CloseAndRecv() (*EchoResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nmonBGPLSServiceClient) BidirectionalStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonBGPLSService_BidirectionalStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonBGPLSService_serviceDesc.Streams[2], "/nmonlistenerapi.NmonBGPLSService/BidirectionalStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonBGPLSServiceBidirectionalStreamingEchoClient{stream}
	return x, nil
}

type NmonBGPLSService_BidirectionalStreamingEchoClient interface {
	Send(*EchoRequest) error
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonBGPLSServiceBidirectionalStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonBGPLSServiceBidirectionalStreamingEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nmonBGPLSServiceBidirectionalStreamingEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NmonBGPLSServiceServer is the server API for NmonBGPLSService service.
type NmonBGPLSServiceServer interface {
	SetIgpNode(context.Context, *IgpNode) (*IgpNode, error)
	SetIgpLink(context.Context, *IgpLink) (*IgpLink, error)
	AddIgpNode(context.Context, *IgpNode) (*IgpNode, error)
	AddIgpLink(context.Context, *IgpLink) (*IgpLink, error)
	// UnaryEcho is unary echo.
	UnaryEcho(context.Context, *EchoRequest) (*EchoResponse, error)
	// ServerStreamingEcho is server side streaming.
	ServerStreamingEcho(*EchoRequest, NmonBGPLSService_ServerStreamingEchoServer) error
	// ClientStreamingEcho is client side streaming.
	ClientStreamingEcho(NmonBGPLSService_ClientStreamingEchoServer) error
	// BidirectionalStreamingEcho is bidir streaming.
	BidirectionalStreamingEcho(NmonBGPLSService_BidirectionalStreamingEchoServer) error
}

// UnimplementedNmonBGPLSServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNmonBGPLSServiceServer struct {
}

func (*UnimplementedNmonBGPLSServiceServer) SetIgpNode(ctx context.Context, req *IgpNode) (*IgpNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIgpNode not implemented")
}
func (*UnimplementedNmonBGPLSServiceServer) SetIgpLink(ctx context.Context, req *IgpLink) (*IgpLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIgpLink not implemented")
}
func (*UnimplementedNmonBGPLSServiceServer) AddIgpNode(ctx context.Context, req *IgpNode) (*IgpNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddIgpNode not implemented")
}
func (*UnimplementedNmonBGPLSServiceServer) AddIgpLink(ctx context.Context, req *IgpLink) (*IgpLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddIgpLink not implemented")
}
func (*UnimplementedNmonBGPLSServiceServer) UnaryEcho(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnaryEcho not implemented")
}
func (*UnimplementedNmonBGPLSServiceServer) ServerStreamingEcho(req *EchoRequest, srv NmonBGPLSService_ServerStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method ServerStreamingEcho not implemented")
}
func (*UnimplementedNmonBGPLSServiceServer) ClientStreamingEcho(srv NmonBGPLSService_ClientStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method ClientStreamingEcho not implemented")
}
func (*UnimplementedNmonBGPLSServiceServer) BidirectionalStreamingEcho(srv NmonBGPLSService_BidirectionalStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method BidirectionalStreamingEcho not implemented")
}

func RegisterNmonBGPLSServiceServer(s *grpc.Server, srv NmonBGPLSServiceServer) {
	s.RegisterService(&_NmonBGPLSService_serviceDesc, srv)
}

func _NmonBGPLSService_SetIgpNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IgpNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonBGPLSServiceServer).SetIgpNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonBGPLSService/SetIgpNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonBGPLSServiceServer).SetIgpNode(ctx, req.(*IgpNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonBGPLSService_SetIgpLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IgpLink)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonBGPLSServiceServer).SetIgpLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonBGPLSService/SetIgpLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonBGPLSServiceServer).SetIgpLink(ctx, req.(*IgpLink))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonBGPLSService_AddIgpNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IgpNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonBGPLSServiceServer).AddIgpNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonBGPLSService/AddIgpNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonBGPLSServiceServer).AddIgpNode(ctx, req.(*IgpNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonBGPLSService_AddIgpLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IgpLink)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonBGPLSServiceServer).AddIgpLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonBGPLSService/AddIgpLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonBGPLSServiceServer).AddIgpLink(ctx, req.(*IgpLink))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonBGPLSService_UnaryEcho_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonBGPLSServiceServer).UnaryEcho(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonBGPLSService/UnaryEcho",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonBGPLSServiceServer).UnaryEcho(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonBGPLSService_ServerStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EchoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NmonBGPLSServiceServer).ServerStreamingEcho(m, &nmonBGPLSServiceServerStreamingEchoServer{stream})
}

type NmonBGPLSService_ServerStreamingEchoServer interface {
	Send(*EchoResponse) error
	grpc.ServerStream
}

type nmonBGPLSServiceServerStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonBGPLSServiceServerStreamingEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NmonBGPLSService_ClientStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NmonBGPLSServiceServer).ClientStreamingEcho(&nmonBGPLSServiceClientStreamingEchoServer{stream})
}

type NmonBGPLSService_ClientStreamingEchoServer interface {
	SendAndClose(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type nmonBGPLSServiceClientStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonBGPLSServiceClientStreamingEchoServer) SendAndClose(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nmonBGPLSServiceClientStreamingEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NmonBGPLSService_BidirectionalStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NmonBGPLSServiceServer).BidirectionalStreamingEcho(&nmonBGPLSServiceBidirectionalStreamingEchoServer{stream})
}

type NmonBGPLSService_BidirectionalStreamingEchoServer interface {
	Send(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type nmonBGPLSServiceBidirectionalStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonBGPLSServiceBidirectionalStreamingEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nmonBGPLSServiceBidirectionalStreamingEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _NmonBGPLSService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nmonlistenerapi.NmonBGPLSService",
	HandlerType: (*NmonBGPLSServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetIgpNode",
			Handler:    _NmonBGPLSService_SetIgpNode_Handler,
		},
		{
			MethodName: "SetIgpLink",
			Handler:    _NmonBGPLSService_SetIgpLink_Handler,
		},
		{
			MethodName: "AddIgpNode",
			Handler:    _NmonBGPLSService_AddIgpNode_Handler,
		},
		{
			MethodName: "AddIgpLink",
			Handler:    _NmonBGPLSService_AddIgpLink_Handler,
		},
		{
			MethodName: "UnaryEcho",
			Handler:    _NmonBGPLSService_UnaryEcho_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServerStreamingEcho",
			Handler:       _NmonBGPLSService_ServerStreamingEcho_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ClientStreamingEcho",
			Handler:       _NmonBGPLSService_ClientStreamingEcho_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BidirectionalStreamingEcho",
			Handler:       _NmonBGPLSService_BidirectionalStreamingEcho_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "nmonlistenerapi.proto",
}

// NmonDatabaseServiceClient is the client API for NmonDatabaseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NmonDatabaseServiceClient interface {
	UpdateCity(ctx context.Context, in *DatabaseCityUpdateRequest, opts ...grpc.CallOption) (*DatabaseCityUpdateRequest, error)
	UpdatePop(ctx context.Context, in *DatabasePopUpdateRequest, opts ...grpc.CallOption) (*DatabasePopUpdateRequest, error)
	UpdateNode(ctx context.Context, in *DatabaseIgpNodeUpdateRequest, opts ...grpc.CallOption) (*DatabaseIgpNodeUpdateRequest, error)
	UpdateLink(ctx context.Context, in *DatabaseLinkUpdateMessage, opts ...grpc.CallOption) (*DatabaseLinkUpdateMessage, error)
	UpdateVertex(ctx context.Context, in *DatabaseUpdateVertexMessage, opts ...grpc.CallOption) (*DatabaseUpdateVertexMessage, error)
	UpdateEdge(ctx context.Context, in *DatabaseUpdateEdgeMessage, opts ...grpc.CallOption) (*DatabaseUpdateEdgeMessage, error)
	UnaryEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	// ServerStreamingEcho is server side streaming.
	ServerStreamingEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (NmonDatabaseService_ServerStreamingEchoClient, error)
	// ClientStreamingEcho is client side streaming.
	ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonDatabaseService_ClientStreamingEchoClient, error)
	// BidirectionalStreamingEcho is bidir streaming.
	BidirectionalStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonDatabaseService_BidirectionalStreamingEchoClient, error)
}

type nmonDatabaseServiceClient struct {
	cc *grpc.ClientConn
}

func NewNmonDatabaseServiceClient(cc *grpc.ClientConn) NmonDatabaseServiceClient {
	return &nmonDatabaseServiceClient{cc}
}

func (c *nmonDatabaseServiceClient) UpdateCity(ctx context.Context, in *DatabaseCityUpdateRequest, opts ...grpc.CallOption) (*DatabaseCityUpdateRequest, error) {
	out := new(DatabaseCityUpdateRequest)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonDatabaseService/UpdateCity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonDatabaseServiceClient) UpdatePop(ctx context.Context, in *DatabasePopUpdateRequest, opts ...grpc.CallOption) (*DatabasePopUpdateRequest, error) {
	out := new(DatabasePopUpdateRequest)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonDatabaseService/UpdatePop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonDatabaseServiceClient) UpdateNode(ctx context.Context, in *DatabaseIgpNodeUpdateRequest, opts ...grpc.CallOption) (*DatabaseIgpNodeUpdateRequest, error) {
	out := new(DatabaseIgpNodeUpdateRequest)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonDatabaseService/UpdateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonDatabaseServiceClient) UpdateLink(ctx context.Context, in *DatabaseLinkUpdateMessage, opts ...grpc.CallOption) (*DatabaseLinkUpdateMessage, error) {
	out := new(DatabaseLinkUpdateMessage)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonDatabaseService/UpdateLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonDatabaseServiceClient) UpdateVertex(ctx context.Context, in *DatabaseUpdateVertexMessage, opts ...grpc.CallOption) (*DatabaseUpdateVertexMessage, error) {
	out := new(DatabaseUpdateVertexMessage)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonDatabaseService/UpdateVertex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonDatabaseServiceClient) UpdateEdge(ctx context.Context, in *DatabaseUpdateEdgeMessage, opts ...grpc.CallOption) (*DatabaseUpdateEdgeMessage, error) {
	out := new(DatabaseUpdateEdgeMessage)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonDatabaseService/UpdateEdge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonDatabaseServiceClient) UnaryEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonDatabaseService/UnaryEcho", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonDatabaseServiceClient) ServerStreamingEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (NmonDatabaseService_ServerStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonDatabaseService_serviceDesc.Streams[0], "/nmonlistenerapi.NmonDatabaseService/ServerStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonDatabaseServiceServerStreamingEchoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NmonDatabaseService_ServerStreamingEchoClient interface {
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonDatabaseServiceServerStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonDatabaseServiceServerStreamingEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nmonDatabaseServiceClient) ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonDatabaseService_ClientStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonDatabaseService_serviceDesc.Streams[1], "/nmonlistenerapi.NmonDatabaseService/ClientStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonDatabaseServiceClientStreamingEchoClient{stream}
	return x, nil
}

type NmonDatabaseService_ClientStreamingEchoClient interface {
	Send(*EchoRequest) error
	CloseAndRecv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonDatabaseServiceClientStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonDatabaseServiceClientStreamingEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nmonDatabaseServiceClientStreamingEchoClient) CloseAndRecv() (*EchoResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nmonDatabaseServiceClient) BidirectionalStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonDatabaseService_BidirectionalStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonDatabaseService_serviceDesc.Streams[2], "/nmonlistenerapi.NmonDatabaseService/BidirectionalStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonDatabaseServiceBidirectionalStreamingEchoClient{stream}
	return x, nil
}

type NmonDatabaseService_BidirectionalStreamingEchoClient interface {
	Send(*EchoRequest) error
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonDatabaseServiceBidirectionalStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonDatabaseServiceBidirectionalStreamingEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nmonDatabaseServiceBidirectionalStreamingEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NmonDatabaseServiceServer is the server API for NmonDatabaseService service.
type NmonDatabaseServiceServer interface {
	UpdateCity(context.Context, *DatabaseCityUpdateRequest) (*DatabaseCityUpdateRequest, error)
	UpdatePop(context.Context, *DatabasePopUpdateRequest) (*DatabasePopUpdateRequest, error)
	UpdateNode(context.Context, *DatabaseIgpNodeUpdateRequest) (*DatabaseIgpNodeUpdateRequest, error)
	UpdateLink(context.Context, *DatabaseLinkUpdateMessage) (*DatabaseLinkUpdateMessage, error)
	UpdateVertex(context.Context, *DatabaseUpdateVertexMessage) (*DatabaseUpdateVertexMessage, error)
	UpdateEdge(context.Context, *DatabaseUpdateEdgeMessage) (*DatabaseUpdateEdgeMessage, error)
	UnaryEcho(context.Context, *EchoRequest) (*EchoResponse, error)
	// ServerStreamingEcho is server side streaming.
	ServerStreamingEcho(*EchoRequest, NmonDatabaseService_ServerStreamingEchoServer) error
	// ClientStreamingEcho is client side streaming.
	ClientStreamingEcho(NmonDatabaseService_ClientStreamingEchoServer) error
	// BidirectionalStreamingEcho is bidir streaming.
	BidirectionalStreamingEcho(NmonDatabaseService_BidirectionalStreamingEchoServer) error
}

// UnimplementedNmonDatabaseServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNmonDatabaseServiceServer struct {
}

func (*UnimplementedNmonDatabaseServiceServer) UpdateCity(ctx context.Context, req *DatabaseCityUpdateRequest) (*DatabaseCityUpdateRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCity not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) UpdatePop(ctx context.Context, req *DatabasePopUpdateRequest) (*DatabasePopUpdateRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePop not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) UpdateNode(ctx context.Context, req *DatabaseIgpNodeUpdateRequest) (*DatabaseIgpNodeUpdateRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNode not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) UpdateLink(ctx context.Context, req *DatabaseLinkUpdateMessage) (*DatabaseLinkUpdateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLink not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) UpdateVertex(ctx context.Context, req *DatabaseUpdateVertexMessage) (*DatabaseUpdateVertexMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVertex not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) UpdateEdge(ctx context.Context, req *DatabaseUpdateEdgeMessage) (*DatabaseUpdateEdgeMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEdge not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) UnaryEcho(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnaryEcho not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) ServerStreamingEcho(req *EchoRequest, srv NmonDatabaseService_ServerStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method ServerStreamingEcho not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) ClientStreamingEcho(srv NmonDatabaseService_ClientStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method ClientStreamingEcho not implemented")
}
func (*UnimplementedNmonDatabaseServiceServer) BidirectionalStreamingEcho(srv NmonDatabaseService_BidirectionalStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method BidirectionalStreamingEcho not implemented")
}

func RegisterNmonDatabaseServiceServer(s *grpc.Server, srv NmonDatabaseServiceServer) {
	s.RegisterService(&_NmonDatabaseService_serviceDesc, srv)
}

func _NmonDatabaseService_UpdateCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseCityUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonDatabaseServiceServer).UpdateCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonDatabaseService/UpdateCity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonDatabaseServiceServer).UpdateCity(ctx, req.(*DatabaseCityUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonDatabaseService_UpdatePop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabasePopUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonDatabaseServiceServer).UpdatePop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonDatabaseService/UpdatePop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonDatabaseServiceServer).UpdatePop(ctx, req.(*DatabasePopUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonDatabaseService_UpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseIgpNodeUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonDatabaseServiceServer).UpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonDatabaseService/UpdateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonDatabaseServiceServer).UpdateNode(ctx, req.(*DatabaseIgpNodeUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonDatabaseService_UpdateLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseLinkUpdateMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonDatabaseServiceServer).UpdateLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonDatabaseService/UpdateLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonDatabaseServiceServer).UpdateLink(ctx, req.(*DatabaseLinkUpdateMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonDatabaseService_UpdateVertex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUpdateVertexMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonDatabaseServiceServer).UpdateVertex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonDatabaseService/UpdateVertex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonDatabaseServiceServer).UpdateVertex(ctx, req.(*DatabaseUpdateVertexMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonDatabaseService_UpdateEdge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUpdateEdgeMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonDatabaseServiceServer).UpdateEdge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonDatabaseService/UpdateEdge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonDatabaseServiceServer).UpdateEdge(ctx, req.(*DatabaseUpdateEdgeMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonDatabaseService_UnaryEcho_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonDatabaseServiceServer).UnaryEcho(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonDatabaseService/UnaryEcho",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonDatabaseServiceServer).UnaryEcho(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonDatabaseService_ServerStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EchoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NmonDatabaseServiceServer).ServerStreamingEcho(m, &nmonDatabaseServiceServerStreamingEchoServer{stream})
}

type NmonDatabaseService_ServerStreamingEchoServer interface {
	Send(*EchoResponse) error
	grpc.ServerStream
}

type nmonDatabaseServiceServerStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonDatabaseServiceServerStreamingEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NmonDatabaseService_ClientStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NmonDatabaseServiceServer).ClientStreamingEcho(&nmonDatabaseServiceClientStreamingEchoServer{stream})
}

type NmonDatabaseService_ClientStreamingEchoServer interface {
	SendAndClose(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type nmonDatabaseServiceClientStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonDatabaseServiceClientStreamingEchoServer) SendAndClose(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nmonDatabaseServiceClientStreamingEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NmonDatabaseService_BidirectionalStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NmonDatabaseServiceServer).BidirectionalStreamingEcho(&nmonDatabaseServiceBidirectionalStreamingEchoServer{stream})
}

type NmonDatabaseService_BidirectionalStreamingEchoServer interface {
	Send(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type nmonDatabaseServiceBidirectionalStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonDatabaseServiceBidirectionalStreamingEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nmonDatabaseServiceBidirectionalStreamingEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _NmonDatabaseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nmonlistenerapi.NmonDatabaseService",
	HandlerType: (*NmonDatabaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateCity",
			Handler:    _NmonDatabaseService_UpdateCity_Handler,
		},
		{
			MethodName: "UpdatePop",
			Handler:    _NmonDatabaseService_UpdatePop_Handler,
		},
		{
			MethodName: "UpdateNode",
			Handler:    _NmonDatabaseService_UpdateNode_Handler,
		},
		{
			MethodName: "UpdateLink",
			Handler:    _NmonDatabaseService_UpdateLink_Handler,
		},
		{
			MethodName: "UpdateVertex",
			Handler:    _NmonDatabaseService_UpdateVertex_Handler,
		},
		{
			MethodName: "UpdateEdge",
			Handler:    _NmonDatabaseService_UpdateEdge_Handler,
		},
		{
			MethodName: "UnaryEcho",
			Handler:    _NmonDatabaseService_UnaryEcho_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServerStreamingEcho",
			Handler:       _NmonDatabaseService_ServerStreamingEcho_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ClientStreamingEcho",
			Handler:       _NmonDatabaseService_ClientStreamingEcho_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BidirectionalStreamingEcho",
			Handler:       _NmonDatabaseService_BidirectionalStreamingEcho_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "nmonlistenerapi.proto",
}

// NmonGuiServiceClient is the client API for NmonGuiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NmonGuiServiceClient interface {
	GetTopo(ctx context.Context, in *Topo, opts ...grpc.CallOption) (*Topo, error)
	UpdateTopo(ctx context.Context, opts ...grpc.CallOption) (NmonGuiService_UpdateTopoClient, error)
	// UnaryEcho is unary echo.
	UnaryEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	// ServerStreamingEcho is server side streaming.
	ServerStreamingEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (NmonGuiService_ServerStreamingEchoClient, error)
	// ClientStreamingEcho is client side streaming.
	ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonGuiService_ClientStreamingEchoClient, error)
	// BidirectionalStreamingEcho is bidir streaming.
	BidirectionalStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonGuiService_BidirectionalStreamingEchoClient, error)
}

type nmonGuiServiceClient struct {
	cc *grpc.ClientConn
}

func NewNmonGuiServiceClient(cc *grpc.ClientConn) NmonGuiServiceClient {
	return &nmonGuiServiceClient{cc}
}

func (c *nmonGuiServiceClient) GetTopo(ctx context.Context, in *Topo, opts ...grpc.CallOption) (*Topo, error) {
	out := new(Topo)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonGuiService/GetTopo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonGuiServiceClient) UpdateTopo(ctx context.Context, opts ...grpc.CallOption) (NmonGuiService_UpdateTopoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonGuiService_serviceDesc.Streams[0], "/nmonlistenerapi.NmonGuiService/UpdateTopo", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonGuiServiceUpdateTopoClient{stream}
	return x, nil
}

type NmonGuiService_UpdateTopoClient interface {
	Send(*Topo) error
	Recv() (*Topo, error)
	grpc.ClientStream
}

type nmonGuiServiceUpdateTopoClient struct {
	grpc.ClientStream
}

func (x *nmonGuiServiceUpdateTopoClient) Send(m *Topo) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nmonGuiServiceUpdateTopoClient) Recv() (*Topo, error) {
	m := new(Topo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nmonGuiServiceClient) UnaryEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := c.cc.Invoke(ctx, "/nmonlistenerapi.NmonGuiService/UnaryEcho", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nmonGuiServiceClient) ServerStreamingEcho(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (NmonGuiService_ServerStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonGuiService_serviceDesc.Streams[1], "/nmonlistenerapi.NmonGuiService/ServerStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonGuiServiceServerStreamingEchoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NmonGuiService_ServerStreamingEchoClient interface {
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonGuiServiceServerStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonGuiServiceServerStreamingEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nmonGuiServiceClient) ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonGuiService_ClientStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonGuiService_serviceDesc.Streams[2], "/nmonlistenerapi.NmonGuiService/ClientStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonGuiServiceClientStreamingEchoClient{stream}
	return x, nil
}

type NmonGuiService_ClientStreamingEchoClient interface {
	Send(*EchoRequest) error
	CloseAndRecv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonGuiServiceClientStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonGuiServiceClientStreamingEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nmonGuiServiceClientStreamingEchoClient) CloseAndRecv() (*EchoResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nmonGuiServiceClient) BidirectionalStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (NmonGuiService_BidirectionalStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NmonGuiService_serviceDesc.Streams[3], "/nmonlistenerapi.NmonGuiService/BidirectionalStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &nmonGuiServiceBidirectionalStreamingEchoClient{stream}
	return x, nil
}

type NmonGuiService_BidirectionalStreamingEchoClient interface {
	Send(*EchoRequest) error
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type nmonGuiServiceBidirectionalStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *nmonGuiServiceBidirectionalStreamingEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nmonGuiServiceBidirectionalStreamingEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NmonGuiServiceServer is the server API for NmonGuiService service.
type NmonGuiServiceServer interface {
	GetTopo(context.Context, *Topo) (*Topo, error)
	UpdateTopo(NmonGuiService_UpdateTopoServer) error
	// UnaryEcho is unary echo.
	UnaryEcho(context.Context, *EchoRequest) (*EchoResponse, error)
	// ServerStreamingEcho is server side streaming.
	ServerStreamingEcho(*EchoRequest, NmonGuiService_ServerStreamingEchoServer) error
	// ClientStreamingEcho is client side streaming.
	ClientStreamingEcho(NmonGuiService_ClientStreamingEchoServer) error
	// BidirectionalStreamingEcho is bidir streaming.
	BidirectionalStreamingEcho(NmonGuiService_BidirectionalStreamingEchoServer) error
}

// UnimplementedNmonGuiServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNmonGuiServiceServer struct {
}

func (*UnimplementedNmonGuiServiceServer) GetTopo(ctx context.Context, req *Topo) (*Topo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopo not implemented")
}
func (*UnimplementedNmonGuiServiceServer) UpdateTopo(srv NmonGuiService_UpdateTopoServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateTopo not implemented")
}
func (*UnimplementedNmonGuiServiceServer) UnaryEcho(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnaryEcho not implemented")
}
func (*UnimplementedNmonGuiServiceServer) ServerStreamingEcho(req *EchoRequest, srv NmonGuiService_ServerStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method ServerStreamingEcho not implemented")
}
func (*UnimplementedNmonGuiServiceServer) ClientStreamingEcho(srv NmonGuiService_ClientStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method ClientStreamingEcho not implemented")
}
func (*UnimplementedNmonGuiServiceServer) BidirectionalStreamingEcho(srv NmonGuiService_BidirectionalStreamingEchoServer) error {
	return status.Errorf(codes.Unimplemented, "method BidirectionalStreamingEcho not implemented")
}

func RegisterNmonGuiServiceServer(s *grpc.Server, srv NmonGuiServiceServer) {
	s.RegisterService(&_NmonGuiService_serviceDesc, srv)
}

func _NmonGuiService_GetTopo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Topo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonGuiServiceServer).GetTopo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonGuiService/GetTopo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonGuiServiceServer).GetTopo(ctx, req.(*Topo))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonGuiService_UpdateTopo_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NmonGuiServiceServer).UpdateTopo(&nmonGuiServiceUpdateTopoServer{stream})
}

type NmonGuiService_UpdateTopoServer interface {
	Send(*Topo) error
	Recv() (*Topo, error)
	grpc.ServerStream
}

type nmonGuiServiceUpdateTopoServer struct {
	grpc.ServerStream
}

func (x *nmonGuiServiceUpdateTopoServer) Send(m *Topo) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nmonGuiServiceUpdateTopoServer) Recv() (*Topo, error) {
	m := new(Topo)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NmonGuiService_UnaryEcho_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NmonGuiServiceServer).UnaryEcho(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nmonlistenerapi.NmonGuiService/UnaryEcho",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NmonGuiServiceServer).UnaryEcho(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NmonGuiService_ServerStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EchoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NmonGuiServiceServer).ServerStreamingEcho(m, &nmonGuiServiceServerStreamingEchoServer{stream})
}

type NmonGuiService_ServerStreamingEchoServer interface {
	Send(*EchoResponse) error
	grpc.ServerStream
}

type nmonGuiServiceServerStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonGuiServiceServerStreamingEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NmonGuiService_ClientStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NmonGuiServiceServer).ClientStreamingEcho(&nmonGuiServiceClientStreamingEchoServer{stream})
}

type NmonGuiService_ClientStreamingEchoServer interface {
	SendAndClose(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type nmonGuiServiceClientStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonGuiServiceClientStreamingEchoServer) SendAndClose(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nmonGuiServiceClientStreamingEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NmonGuiService_BidirectionalStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NmonGuiServiceServer).BidirectionalStreamingEcho(&nmonGuiServiceBidirectionalStreamingEchoServer{stream})
}

type NmonGuiService_BidirectionalStreamingEchoServer interface {
	Send(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type nmonGuiServiceBidirectionalStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *nmonGuiServiceBidirectionalStreamingEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nmonGuiServiceBidirectionalStreamingEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _NmonGuiService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nmonlistenerapi.NmonGuiService",
	HandlerType: (*NmonGuiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTopo",
			Handler:    _NmonGuiService_GetTopo_Handler,
		},
		{
			MethodName: "UnaryEcho",
			Handler:    _NmonGuiService_UnaryEcho_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpdateTopo",
			Handler:       _NmonGuiService_UpdateTopo_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ServerStreamingEcho",
			Handler:       _NmonGuiService_ServerStreamingEcho_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ClientStreamingEcho",
			Handler:       _NmonGuiService_ClientStreamingEcho_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BidirectionalStreamingEcho",
			Handler:       _NmonGuiService_BidirectionalStreamingEcho_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "nmonlistenerapi.proto",
}
